# CS497-HW3
1. This algorithm first stores the input list, O(N) traversal to read, in an array, O(N) traversal to store, for efficient access, which takes O(2N) time and O(N) space. It then calls a recursive function which stores the middle element of the array as the root, before calling itself on the left half of the array for the left subtree and the right for the right. This recusrion means it is called exactly once for each item in the array, so the time complexity is O(N), as array access is constant time. This continues until every element has been checked, which is when the function is called with the end greater than the beginning. The root node is then returned. Overall, this algoorithm has O(N) time complexity, as it is simply multiple O(N) functions strung together. The algorithm also uses O(N) extra space to store an array.
2. This algorithm first stores the inorder traveral in a hashmap for easy lookup, which takes O(N) time and O(N) space. It then recursively calls a function to create a new node for each element of the preorder traversal. The element's index in the inorder is retrieved from the HashMap, an O(1) function, and then the function is recursively called for elenents before this index as the left tree and after the index as the right. This recusrion occurs until every element has been accesed, making it O(N) time complexity. This approach takes O(N) time overall as well as O(N) additional space for the HashMap. 
